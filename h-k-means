from copy import deepcopy
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import import_data as toolbox_import
from sklearn.cluster import KMeans
import math as m


# Euclidean Distance Caculator
def dist(a, b, ax=1):
    return np.linalg.norm(a - b, axis=ax)


def euclid_distance(x1, x2):
    y = 0
    for i in range(len(x1)):
        y += (x1[i] - x2[i]) ** 2
    return m.sqrt(y)


def cluster(k, Data, medoids):
    cluster_assignments = np.empty(np.size(Data, 0))
    clusters = np.empty((k, Data.shape[1]), dtype=np.float32)
    for i in range(0, np.size(Data, 0)):
        distance = np.empty(k)
        for j in range(0, k):
            x1 = np.empty(np.size(Data, 1))
            for l in range(0, np.size(Data, 1)):
                x1[l] = Data[i, l]
            x2 = medoids[j]
            distance[j] = euclid_distance(x1, x2)
        cluster_assignments[i] = np.argmin(distance.sum(axis=0))

    for i in range(k):
        clusters[i] = np.argmin(cluster_assignments.sum(axis=0))

    return clusters


def h_k_means(dataa, k=3):
    X = np.array(dataa)
    C_dimensions = np.empty((k, X.shape[1]), dtype=np.float32)

    # coordinates of random centriods
    for i in range(k):
        random_cluster = np.random.randint(0, np.max(X), size=X.shape[1])
        C_dimensions[i] = random_cluster

    C = np.array(list(C_dimensions), dtype=np.float32)
    print("Initial Centroids")
    print(C)

    # To store the value of centroids when it updates
    C_old = np.zeros(C.shape)
    # Cluster Lables(0, 1, 2)
    clusters = np.zeros((len(X), k))
    # Error func. - Distance between new centroids and old centroids
    error = dist(C, C_old, None)
    # set empty array's for finding greatest distance
    dist_old = np.empty(shape=k)
    max_dist = np.empty(shape=k)
    max_dist_id = np.empty(shape=k)
    # Loop will run till the error becomes zero
    while error != 0:
        for i in range(len(X)):
            for j in range(k):
                distances = dist(X[i, j], C)
                dist_old = distances
                for d in range(k):
                    if dist_old[d] > max_dist[d]:
                        max_dist[d] = dist_old[d]
                        max_dist_id[d] = int(i)

        # Storing the old centroid values
        C_old = deepcopy(C)
        print('MAX Dist', max_dist, 'with ID', max_dist_id)
        new_X = np.empty(shape=(X.shape[0] - 1, X.shape[1]))
        # Create a temp X without the furthest distance points
        print('shapes', new_X[:, 1].shape, 'And', np.delete(X[:, 1], 15).shape, 'original', X.shape)
        for i in range(k):
            print('erin met ', max_dist_id[i])
            new_X[:, i] = np.delete(X[:, i], max_dist_id[i])

        C = cluster(k, new_X, C)
        print(C, ' old', C_old)
        error = dist(C, C_old, None)
        print('Error', error)
    return C


raw = toolbox_import.convertIntoArray('Data/USCensus1990.data.txt', 69, 2, 10000)

data = np.empty(shape=(10000, 3))

data[:, 0] = raw[:, 31]
data[:, 1] = raw[:, 40]
data[:, 2] = raw[:, 12]

# print(data.shape[1])

print('Eigen cluster', h_k_means(data, 3))
